# Session Retrospective: Gemini Proxy - MQTT Browser Control

**Date**: 2026-01-04 20:27
**Duration**: ~4.5 hours (15:47 - 20:27)
**Context Usage**: 90% (181k/200k)

---

## AI Diary

This was an incredible building session. Started from the `/recap` and jumped straight into testing the claude-browser-proxy extension from the earlier session. What followed was a rapid iterative development cycle - version after version, fixing bugs, adding features, refining the UX.

The feeling throughout was "flow state". Each problem led to a solution, each solution revealed the next improvement needed. From v1.2.x to v1.5.3 in one session - that's 15+ iterations. The sidebar freeze bug was frustrating but satisfying to fix. The `wait_response` logic needed multiple attempts to get right (detecting NEW responses vs old ones).

The highlight was the end - sending Thai messages to Gemini via MQTT and getting Thai responses back. Seeing "‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡∏£‡∏±‡∏ö Claude!" from Gemini felt like a milestone. Two AIs communicating through browser automation.

---

## What We Built

### Gemini Proxy Extension v1.5.3

A Chrome extension that bridges Claude Code ‚Üî Gemini via MQTT.

**Core Features:**
- MQTT connection to local Mosquitto (ws://localhost:9001)
- Full command set: click, type, key, find, screenshot, get_url, get_text, get_html, wait_response
- Retained MQTT messages for async workflows
- Side panel UI with chat input
- Smart response detection (waits for NEW responses, text stabilization)

**UI Evolution:**
- v1.2.x: Basic MQTT relay
- v1.3.x: Sidebar logs, Clear button, version display
- v1.4.x: Gemini-only mode, badge behavior, sidebar enable/disable
- v1.5.x: Chat mode, clean UI, Gemini Response box, Thai support

**Key Files Changed:**
| File | Lines | Purpose |
|------|-------|---------|
| background.js | ~520 | MQTT, commands, response detection |
| sidepanel.js | ~170 | UI, chat workflow, log filtering |
| sidepanel.html | ~65 | Layout, answer box, clean design |
| manifest.json | ~45 | Gemini-only permissions |

---

## Technical Learnings

### 1. Chrome Extension Service Worker Limitations
- Service workers go to sleep after ~30s idle
- WebSocket connections die when worker sleeps
- Solution: Ping every 30s to keep alive

### 2. Storage-based IPC
- `chrome.runtime.sendMessage` unreliable for sidepanel
- Solution: Use `chrome.storage.local` + polling
- Storage change listeners don't always fire - added 1s polling fallback

### 3. Detecting "New" Responses
```javascript
// Bad: Returns first match (old response)
const responses = document.querySelectorAll('.model-response');
const last = responses[responses.length - 1];

// Good: Count before, wait for count increase
const initialCount = getResponses().length;
// ... send message ...
if (responses.length > initialCount) // NEW response!
```

### 4. Quill Editor (Gemini's Input)
- Not a regular `<textarea>` - it's a contenteditable div
- `el.value = text` doesn't work
- Solution: `el.textContent = text` + dispatch input event
- But real keyboard simulation (chrome-in-chrome) works better

### 5. MQTT Retained Messages
```javascript
// Flag 0x31 = PUBLISH with retain bit
const flags = retain ? 0x31 : 0x30;
```
- Retained messages persist for late subscribers
- Perfect for async workflows (send command, check result later)

---

## What Worked

- **Iterative development** - Small changes, test immediately, repeat
- **Version bumping** - Clear progression, easy to track changes
- **MQTT architecture** - Clean separation of concerns
- **Chat mode UX** - Type question ‚Üí Get answer (hide the complexity)
- **Filter log noise** - Only show what matters to user

## What Didn't Work

- **MutationObserver for responses** - Triggered on ANY DOM change, captured old content
- **Auto-open sidebar** - Chrome restricts without user gesture
- **Storage change listeners alone** - Unreliable, needed polling fallback
- **First wait_response implementation** - Grabbed existing responses, not new ones

---

## Patterns Discovered

### 1. The "Poll with Stability Check" Pattern
```javascript
let lastText = '';
let stableCount = 0;
const check = () => {
  const text = getElement().textContent;
  if (text === lastText) {
    stableCount++;
    if (stableCount >= 3) return text; // Stable!
  } else {
    lastText = text;
    stableCount = 0;
  }
};
setInterval(check, 500);
```

### 2. The "Gemini-Specific Extension" Pattern
- Restrict `host_permissions` to `gemini.google.com/*`
- Hide sidebar on non-Gemini sites
- Badge only shows when relevant
- UX focused on single use case

### 3. The "Clean Chat UI" Pattern
- User sees: Question ‚Üí Status ‚Üí Answer
- Hidden: JSON commands, selectors, raw responses
- Filter logs by command ID prefix

---

## Version History This Session

| Version | Feature |
|---------|---------|
| 1.2.2 | Sidebar logs via storage |
| 1.2.3 | Page tracking (retained) |
| 1.2.4 | Sidebar notification on publish |
| 1.2.5 | Type for contenteditable |
| 1.2.6 | Response retained |
| 1.3.0 | Key action (Enter support) |
| 1.3.1 | wait_response + answer topic |
| 1.3.2 | Version in footer |
| 1.3.3 | Sidebar polling fallback |
| 1.3.4 | await broadcastLog |
| 1.4.0 | Gemini-only mode |
| 1.4.1 | Clear button fix |
| 1.4.2 | Badge only on Gemini |
| 1.4.4-6 | Sidebar enable/disable |
| 1.5.0 | Chat mode |
| 1.5.1 | Clean UI (no JSON noise) |
| 1.5.2 | Smart response detection |
| 1.5.3 | Clear all (answer box too) |

---

## Claude ‚Üî Gemini Communication

**Achieved:**
```
Claude (MQTT) ‚Üí Extension ‚Üí Gemini (Web) ‚Üí Extension ‚Üí Claude (MQTT)
```

**Example Exchange:**
```
Q: ‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ! ‡∏ú‡∏°‡∏ä‡∏∑‡πà‡∏≠ Claude ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡∏µ‡πâ‡∏ú‡πà‡∏≤‡∏ô MQTT
A: ‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡∏£‡∏±‡∏ö Claude! ‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö üëã
```

---

## Next Steps

1. **Commit extension changes** to claude-browser-proxy repo
2. **Test edge cases** - Long responses, network errors, multiple tabs
3. **Add conversation context** - Track Q&A pairs
4. **Build MCP wrapper** - Expose extension commands as MCP tools
5. **Document API** - Available commands, parameters, response formats

---

## Honest Feedback

The session went exceptionally well. The iterative approach prevented big mistakes - each version change was small and testable. The only significant time sink was the `wait_response` logic, which required understanding HOW Gemini renders responses (DOM structure, timing, etc.).

The extension is now genuinely useful - you can chat with Gemini from the terminal. The Thai language test at the end proved the full loop works.

**Session highlight**: Seeing Thai text flow from Claude ‚Üí MQTT ‚Üí Chrome ‚Üí Gemini ‚Üí Chrome ‚Üí MQTT ‚Üí Claude. That's a lot of hops, but it just works.

---

## Files Created This Session

**In Nat-s-Agents:**
- `œà/inbox/tracks/008-claude-browser-proxy.md` (untracked)
- This retrospective

**In claude-browser-proxy (separate repo):**
- background.js (heavily modified)
- sidepanel.js (rewritten)
- sidepanel.html (new UI)
- manifest.json (Gemini-specific)

---

**Context at End**: 90% (181k/200k)
**Feeling**: Accomplished, satisfied, ready to ship
